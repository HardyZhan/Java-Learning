# Java并发编程之美
### 死锁产生必须具备的四个条件
* 互斥条件:指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
* 请求并持有条件:指线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。
* 不可剥夺条件:指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。
* 环路等待条件:指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0,T1,T2,...,Tn}中的T0正在等待一个T1占用的资源，T1正在等待T2占用的资源,...Tn正在等待已被T0占用的资源。

### 并发和并行
* 并发指的是同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发强调在同一时间段内同时执行
* 并行是说在单位时间内多个任务同时在执行。

### synchronized的内存语义
* 这个内存语义就可以解决共享变量内存可见性的问题。
* 进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。
* 这其实也就是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放时将本地内存中修改的共享变量刷新到主内存。
* 注意：synchronized关键字会引起线程上下文切换并带来线程调度开销。

### 弱形式同步volatile
* 该关键字可以确保对一个变量的更新对其它线程马上可见。
* 当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其它地方，而是会把值刷新回主内存。当其它线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。
* 写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。
* 读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。

### 何时使用volatile关键字
* 写入变量值不依赖变量的当前值。
* 读写变量值时没有加锁。

### 乐观锁与悲观锁
* 悲观锁：指对数据被外界修改持保守态度，认为数据很容易就会被其它线程修改，所以在数据被处理前对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。
* 乐观锁:它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。

### 公平锁与非公平锁
* 公平锁，表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求的线程将最早获取到锁。
* 非公平锁，在运行时闯入，也就是先来不一定先得。

### 独占锁与共享锁
* 独占锁，保证任何时候都只有一个线程能得到锁。是一种悲观锁。
* 共享锁，可以同时由多个线程持有。例如ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作。是一种乐观锁。

### AQS——锁的底层支持
* AbstractQueuedSynchronizer抽象同步队列简称AQS，

